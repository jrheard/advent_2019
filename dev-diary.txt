7/11/20

let's do this!
starting with day 1

alg was pretty straightforward

when i got to part b, i initially tried to use a loop {}
but i was having issues reassigning a var that lived outside of the loop
couldn't figure out the answer by googling
so i switched to recursion which made the problem go away :]

next up, i had this utility function

pub fn parse_ints_from_file(filename: &str) -> Vec<i32> {
    let contents = fs::read_to_string(filename).unwrap();

    contents
        .lines()
        .map(|x| x.parse::<i32>().unwrap())
        .collect()
}

and i wanted to figure out how to make it generic

i ended up trying this out

pub fn parse_ints_from_file<T: FromStr + Debug>(filename: &str) -> Vec<T> {
    let contents = fs::read_to_string(filename).unwrap();
    contents.lines().map(|x| x.parse::<T>().unwrap()).collect()
}

but it gives this error:

error[E0599]: no method named `unwrap` found for enum `std::result::Result<T, <T as std::str::FromStr>::Err>` in the current scope
 --> src/util.rs:8:45
  |
8 |     contents.lines().map(|x| x.parse::<T>().unwrap()).collect()
  |                                             ^^^^^^ method not found in `std::result::Result<T, <T as std::str::FromStr>::Err>`
  |
  = note: the method `unwrap` exists but the following trait bounds were not satisfied:
          `<T as std::str::FromStr>::Err: std::fmt::Debug`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0599`.
error: could not compile `advent_2019`.

which i can't figure out what to make of.

made a rust playground link:
https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=ffeee4b54d862e99387b644c9d03d19b
and sent it to smt asking for advice!

will sent back this:

pub fn parse_ints_from_file_generic<T: FromStr + Debug>(filename: &str) -> Vec<T> where <T as std::str::FromStr>::Err: std::fmt::Debug {
    let contents = fs::read_to_string(filename).unwrap();

    contents
        .lines()
        .map(|x| {
            let parsed = x.parse::<T>();
            parsed.unwrap()
        })
        .collect()
}

which he acknowledges is hideous

smt solved it!!

pub fn parse_lines_from_file<T: FromStr>(filename: &str) -> Vec<T> {
    let contents = fs::read_to_string(filename).unwrap();

    contents
        .lines()
        .map(|x| {
            x.parse::<T>()
                .map_err(|_| format!("unable to parse {:?}", x))
                .unwrap()
        })
        .collect()
}

he says:
    unwrap() expects to print the "Debug" of whatever the Error was from the Result type
    so it requires that the error implements Debug
    that's why mapping the error to a string fixed it, because String implements Debug

neat!

happened to open this article about docs

https://blog.guillaume-gomez.fr/articles/2020-03-12+Guide+on+how+to+write+documentation+for+a+Rust+crate
    this is very good!
    no_run is interesting
    so is the thing about putting # at the beginning of lines that you don't want to show up in the docs

    rustdoc lints are neat too! v good for libraries obviously

ok, so looking at day 2

you have a tape
you have instructions, groups of four ints (or one int for stop-program)

opcode 1 is add
1, idx_1, idx_2, dst

opcode 2 is mul
2, idx_1, idx_2, mul

opcode 99 is stop program

you process an instruction - a group of 4 integers on the tape - and then step forward 4 to the next one

so! we need a tape

it'll be a vec of i32s

===

7/12/20

ok day 2 was pretty ez and also pretty fun

looks like it's the setup for some future days

i'll definitely be extracting this run_program() stuff out into a separate file for reuse later
but for now let's just go right into day 3

ok so 3 is interesting
one particularly interesting thing about it is that the grid has no specified size

so i could just try to make a huge 2d vector but that would be dumb and gross
but like it would work, just be inefficient and slow

is there a more efficient way to represent this?

what if each wire is represented as a series of (x, y) positions?

that seems better to me

then we could just check to see which elements are in both vectors

DONE learn more about into_iter, https://stackoverflow.com/questions/34733811/what-is-the-difference-between-iter-and-into-iter

https://hermanradtke.com/2015/06/22/effectively-using-iterators-in-rust.html
    "I tend to use .iter() most. I try to be very concious and deliberate
    about when I move resources and default to borrowing (or referencing)
    first. The reference created by .iter() is short-lived, so we can move or
    use our original value afterwards. If you find yourself running into does
    not live long enough, move errors or using the .clone() function, this is
    a sign that you probably want to use .into_iter() instead."

done profile 3a, i'm expecting to see huge slowdown bc of tons of tiny allocations
    https://carol-nichols.com/2017/04/20/rust-profiling-with-dtrace-on-osx/ good tips

i think that it's gonna be bc i make so many tiny strings
i think that instead it would be a lot better to read each wire string in one pass
eg have a function that returns a slice of the string up until the next comma, then operate on that

looks like most of our time is actually spent initializing the hashset?

https://stackoverflow.com/questions/44575380/is-there-any-way-to-insert-multiple-entries-into-a-hashmap-at-once-in-rust

ok you know what
this is actually all fine
when built in release mode, the whole program so far runs in 0.04 seconds
so 3a is fine for now
let's see if it falls over when it comes time for 3b though!!

it didn't :)

ok, i've been reading chapters of the book here and there
just finished structs and enums
and made it to the modules chapter!
but i think a lot changed after the paper book was written, re: modules, 2018 edition, etc
so i'm going to read the online version of that chapter instead, hopefully it's more up to date

https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html
    ya, in https://github.com/rust-lang/book/issues/1888 carol says ch 7 was "totally reworked"

    struct fields are private by default, but can be made public one by one
    by contrast, enums are also private by default, but if they're public then all of their variants are public
    which makes sense!

    oh, i figured out why i couldn't use `use` in this new project
    it was because i didn't have a `src/lib.rs` like i do in advent_2018

    "Using a semicolon after mod front_of_house rather than using a block
    tells Rust to load the contents of the module from another file with the
    same name as the module."

oooh https://doc.rust-lang.org/stable/edition-guide/ should be a good reread

ok cool

4a was easy to implement

kinda slow tho! nothing crazy, but not fast

for fun i flipped the conditionals around, checking nondecreasing first, and that made it about twice as fast
neat!

and then i changed it so that
instead of making a jillion tiny vectors from scratch
we just allocate a single vector that we use as a buffer
and that shaved the bulk of the rest of the time off :]
not my usual way of doing things, but there's a reason it's a common pattern!

ok let's look at day 5!

so it looks like it's time to revisit the opcodes/memory/program stuff

we're handling two more opcodes, with different lengths

so i think it's time to make opcodes a more first-class concept

or tbh maybe not, i think i can get away with a long match() for now

i'm not sure what the appropriate tool here would be - structs? enums?

i guess there could be an Opcode struct like this

struct Opcode {
    opcode: i32,
    num_args: usize,
}

but then so where does the code live that runs the operation for a particular opcode?

ugh yeah i'll just stick with a match for now
i'll figure out something better later

ok yeah so nvm i went with that struct idea

struct and a match

workin ok so far!

it was necessary+helpful bc the number of args is important to know so that we can
advance the instruction pointer appropriately

ok five is gonna be complicated :)

input+output
and modes
eek

===

7/13/20

ok let's take a look at 5a again

Parameter modes are stored in the same value as the instruction's opcode. The
opcode is a two-digit number based only on the ones and tens digit of the
value, that is, the opcode is the rightmost two digits of the first value in
an instruction. Parameter modes are single digits, one per parameter, read
right-to-left from the opcode: the first parameter's mode is in the hundreds
digit, the second parameter's mode is in the thousands digit, the third
parameter's mode is in the ten-thousands digit, and so on. Any missing modes
are 0.

maybe a parse_instruction() fn that returns (opcode: i32, mode: i32)

ahhh i see

took me a second to notice this:

Parameter modes are single digits, *****one per parameter******, read
right-to-left from the opcode: the first parameter's mode is in the hundreds
digit, the second parameter's mode is in the thousands digit, the third
parameter's mode is in the ten-thousands digit, and so on. Any missing modes
are 0.

ok wow this shit is interesting

definitely need a function just for this

but how to get it to not allocate a ton of tiny vecs when parsing/representing parameter modes?

i guess it could take as input a buffer vec<i32> that's initialized with zeroes

    Parameters that an instruction writes to will never be in immediate mode.

makes sense

    Integers can be negative: 1101,100,-1,4,0 is a valid program (find 100 + -1, store the result in position 4).

interesting!

ok so i hacked on 5a for a bit and i thought i had implemented it right
but the output commands are printing out 3
and they're supposed to be printing out 0
and also it crashes after a while
so clearly i've done something wrong

let's work this program out by hand

3,225

take an int (1) as input, store it to 225

1,225,6,6

add the value at 255 and the value at 6, and store the result to 6
the value at 255 is 1
the value at 6 is 1100
so the result is 1101, which we store to 6

1101,1,238,225

add 1 and 238 and store the result to 225
the result is 239, which we store to 225

104,0

print out the value at 0

which is 3!!!!!!
what gives????????

i must be interpreting this program incorrectly somehow

oh fuck wait nvm

104,0

that's "print in immediate mode: 0"
ie print the literal value 0
so why am i printing out 3?

oh, it's because i made a mistake in my print function

i had this:

    println!(">>> {}", memory[args[0] as usize]);

but it should have been this:

    println!(">>> {}", args[0]);

annnd that fixes it and makes my program no longer crash
lolll

ez!

ok i tidied up

still a few more done to resolve

===

7/15/20

finished up 5b!

TODO how can we associate operations' code more closely with their structs? will traits get involved here?

DONE try out a logging library
    https://fasterthanli.me/articles/getting-in-and-out-of-trouble-with-rust-futures has an example
    pretty_env_log it is

===

7/16/20

took a peek at 6a

idea so far:

* construct a tree from the input
* each node in the tree has a `depth` u32
* walk the tree, sum all the depths

constructing the tree will be interesting though

i think first we'll have to parse each line into a tuple of strings
into a hashmap actually imo!
yeah that's the way to go
and then build the tree based on that hashmap of directional relationships

maybe use a stack along the way while building the tree?

hrm hrm hrm
so a single body can have multiple satellites
but each body can only orbit one thing
so there's like a directionality there in the relationship

constructing a hashmap of {satellite: body} is straightforward enough
but how do you walk through that hashmap in order to construct a tree?

i think i want to make a hashmap of {body: vec_of_satellites}
it'll involve a lot of allocations but it'll work fine

ugh
ok so that's fine
but now making the tree is hard :)

do i even need a separate tree?
can i not just walk this hashmap?

i can walk it :)

===

7/18/20

ok, 6b

so we need to figure out how many "orbit transfers" between us and santa
my plan so far:

parse another map of orbits, keep both

so right now i have an outward-facing map of {body: satellites}
i also want an inward-facing map of {satellite: body}

let's come up with terms for these

lol how about BodyToSatellites and SatelliteToBody?
keep it simple

ok cool, done
so now what?

we use satellite_to_body["SAN"] to figure out where he is
and then so the idea i had the other day was

you have a function that's like

find_path_to(destination_body: &str, origin_body: &str, body_to_satellites: &BodyToSatellites) -> Option<u32>

which returns a number like 5 if it finds a path to origin starting from destination, or none if it doesn't

and so starting at san's current position, you call find_path_to("YOU")
and if it returns Some(u32) you have your answer
and if it doesn't, then you walk up the SatelliteToBody chain until you hit a body that has multiple satellites

maybe it'd be worth having `find_path_to()` also take a, like, "candidates" arg, because we'll know that
"YOU" _definitely isn't_ in the direction that we're _coming from_, and instead find_path_to() should only
be checking paths that involve the _other_ satellites of "origin"

anyway that's the rough idea

let's try to get some of this down into code and see how it looks

i'm gonna skip that "candidates" arg stuff for now
it's a perf optimization and kinda fiddly to get right
can reach for it later if we need it

it worked! didnt need candidates after all :)

ok, looking at 7a
to start, we need to come up with the permutations of [0, 1, 2, 3, 4]
gonna go with itertools .permutations()

ok cool that was pretty ez! just fun with iterators and .fold()