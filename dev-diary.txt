7/11/20

let's do this!
starting with day 1

alg was pretty straightforward

when i got to part b, i initially tried to use a loop {}
but i was having issues reassigning a var that lived outside of the loop
couldn't figure out the answer by googling
so i switched to recursion which made the problem go away :]

next up, i had this utility function

pub fn parse_ints_from_file(filename: &str) -> Vec<i32> {
    let contents = fs::read_to_string(filename).unwrap();

    contents
        .lines()
        .map(|x| x.parse::<i32>().unwrap())
        .collect()
}

and i wanted to figure out how to make it generic

i ended up trying this out

pub fn parse_ints_from_file<T: FromStr + Debug>(filename: &str) -> Vec<T> {
    let contents = fs::read_to_string(filename).unwrap();
    contents.lines().map(|x| x.parse::<T>().unwrap()).collect()
}

but it gives this error:

error[E0599]: no method named `unwrap` found for enum `std::result::Result<T, <T as std::str::FromStr>::Err>` in the current scope
 --> src/util.rs:8:45
  |
8 |     contents.lines().map(|x| x.parse::<T>().unwrap()).collect()
  |                                             ^^^^^^ method not found in `std::result::Result<T, <T as std::str::FromStr>::Err>`
  |
  = note: the method `unwrap` exists but the following trait bounds were not satisfied:
          `<T as std::str::FromStr>::Err: std::fmt::Debug`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0599`.
error: could not compile `advent_2019`.

which i can't figure out what to make of.

made a rust playground link:
https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=ffeee4b54d862e99387b644c9d03d19b
and sent it to smt asking for advice!

will sent back this:

pub fn parse_ints_from_file_generic<T: FromStr + Debug>(filename: &str) -> Vec<T> where <T as std::str::FromStr>::Err: std::fmt::Debug {
    let contents = fs::read_to_string(filename).unwrap();

    contents
        .lines()
        .map(|x| {
            let parsed = x.parse::<T>();
            parsed.unwrap()
        })
        .collect()
}

which he acknowledges is hideous

smt solved it!!

pub fn parse_lines_from_file<T: FromStr>(filename: &str) -> Vec<T> {
    let contents = fs::read_to_string(filename).unwrap();

    contents
        .lines()
        .map(|x| {
            x.parse::<T>()
                .map_err(|_| format!("unable to parse {:?}", x))
                .unwrap()
        })
        .collect()
}

he says:
    unwrap() expects to print the "Debug" of whatever the Error was from the Result type
    so it requires that the error implements Debug
    that's why mapping the error to a string fixed it, because String implements Debug

neat!

happened to open this article about docs

https://blog.guillaume-gomez.fr/articles/2020-03-12+Guide+on+how+to+write+documentation+for+a+Rust+crate
    this is very good!
    no_run is interesting
    so is the thing about putting # at the beginning of lines that you don't want to show up in the docs

    rustdoc lints are neat too! v good for libraries obviously

ok, so looking at day 2

you have a tape
you have instructions, groups of four ints (or one int for stop-program)

opcode 1 is add
1, idx_1, idx_2, dst

opcode 2 is mul
2, idx_1, idx_2, mul

opcode 99 is stop program

you process an instruction - a group of 4 integers on the tape - and then step forward 4 to the next one

so! we need a tape

it'll be a vec of i32s

===

7/12/20

ok day 2 was pretty ez and also pretty fun

looks like it's the setup for some future days

i'll definitely be extracting this run_program() stuff out into a separate file for reuse later
but for now let's just go right into day 3

ok so 3 is interesting
one particularly interesting thing about it is that the grid has no specified size

so i could just try to make a huge 2d vector but that would be dumb and gross
but like it would work, just be inefficient and slow

is there a more efficient way to represent this?

what if each wire is represented as a series of (x, y) positions?

that seems better to me

then we could just check to see which elements are in both vectors

DONE learn more about into_iter, https://stackoverflow.com/questions/34733811/what-is-the-difference-between-iter-and-into-iter

https://hermanradtke.com/2015/06/22/effectively-using-iterators-in-rust.html
    "I tend to use .iter() most. I try to be very concious and deliberate
    about when I move resources and default to borrowing (or referencing)
    first. The reference created by .iter() is short-lived, so we can move or
    use our original value afterwards. If you find yourself running into does
    not live long enough, move errors or using the .clone() function, this is
    a sign that you probably want to use .into_iter() instead."

done profile 3a, i'm expecting to see huge slowdown bc of tons of tiny allocations
    https://carol-nichols.com/2017/04/20/rust-profiling-with-dtrace-on-osx/ good tips

i think that it's gonna be bc i make so many tiny strings
i think that instead it would be a lot better to read each wire string in one pass
eg have a function that returns a slice of the string up until the next comma, then operate on that

looks like most of our time is actually spent initializing the hashset?

https://stackoverflow.com/questions/44575380/is-there-any-way-to-insert-multiple-entries-into-a-hashmap-at-once-in-rust

ok you know what
this is actually all fine
when built in release mode, the whole program so far runs in 0.04 seconds
so 3a is fine for now
let's see if it falls over when it comes time for 3b though!!

it didn't :)

ok, i've been reading chapters of the book here and there
just finished structs and enums
and made it to the modules chapter!
but i think a lot changed after the paper book was written, re: modules, 2018 edition, etc
so i'm going to read the online version of that chapter instead, hopefully it's more up to date

https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html
    ya, in https://github.com/rust-lang/book/issues/1888 carol says ch 7 was "totally reworked"

    struct fields are private by default, but can be made public one by one
    by contrast, enums are also private by default, but if they're public then all of their variants are public
    which makes sense!

    oh, i figured out why i couldn't use `use` in this new project
    it was because i didn't have a `src/lib.rs` like i do in advent_2018

    "Using a semicolon after mod front_of_house rather than using a block
    tells Rust to load the contents of the module from another file with the
    same name as the module."

oooh https://doc.rust-lang.org/stable/edition-guide/ should be a good reread

ok cool

4a was easy to implement

kinda slow tho! nothing crazy, but not fast

for fun i flipped the conditionals around, checking nondecreasing first, and that made it about twice as fast
neat!

and then i changed it so that
instead of making a jillion tiny vectors from scratch
we just allocate a single vector that we use as a buffer
and that shaved the bulk of the rest of the time off :]
not my usual way of doing things, but there's a reason it's a common pattern!

ok let's look at day 5!

so it looks like it's time to revisit the opcodes/memory/program stuff

we're handling two more opcodes, with different lengths

so i think it's time to make opcodes a more first-class concept

or tbh maybe not, i think i can get away with a long match() for now

i'm not sure what the appropriate tool here would be - structs? enums?

i guess there could be an Opcode struct like this

struct Opcode {
    opcode: i32,
    num_args: usize,
}

but then so where does the code live that runs the operation for a particular opcode?

ugh yeah i'll just stick with a match for now
i'll figure out something better later

ok yeah so nvm i went with that struct idea

struct and a match

workin ok so far!

it was necessary+helpful bc the number of args is important to know so that we can
advance the instruction pointer appropriately

ok five is gonna be complicated :)

input+output
and modes
eek

===

7/13/20

ok let's take a look at 5a again

Parameter modes are stored in the same value as the instruction's opcode. The
opcode is a two-digit number based only on the ones and tens digit of the
value, that is, the opcode is the rightmost two digits of the first value in
an instruction. Parameter modes are single digits, one per parameter, read
right-to-left from the opcode: the first parameter's mode is in the hundreds
digit, the second parameter's mode is in the thousands digit, the third
parameter's mode is in the ten-thousands digit, and so on. Any missing modes
are 0.

maybe a parse_instruction() fn that returns (opcode: i32, mode: i32)

ahhh i see

took me a second to notice this:

Parameter modes are single digits, *****one per parameter******, read
right-to-left from the opcode: the first parameter's mode is in the hundreds
digit, the second parameter's mode is in the thousands digit, the third
parameter's mode is in the ten-thousands digit, and so on. Any missing modes
are 0.

ok wow this shit is interesting

definitely need a function just for this

but how to get it to not allocate a ton of tiny vecs when parsing/representing parameter modes?

i guess it could take as input a buffer vec<i32> that's initialized with zeroes

    Parameters that an instruction writes to will never be in immediate mode.

makes sense

    Integers can be negative: 1101,100,-1,4,0 is a valid program (find 100 + -1, store the result in position 4).

interesting!

ok so i hacked on 5a for a bit and i thought i had implemented it right
but the output commands are printing out 3
and they're supposed to be printing out 0
and also it crashes after a while
so clearly i've done something wrong

let's work this program out by hand

3,225

take an int (1) as input, store it to 225

1,225,6,6

add the value at 255 and the value at 6, and store the result to 6
the value at 255 is 1
the value at 6 is 1100
so the result is 1101, which we store to 6

1101,1,238,225

add 1 and 238 and store the result to 225
the result is 239, which we store to 225

104,0

print out the value at 0

which is 3!!!!!!
what gives????????

i must be interpreting this program incorrectly somehow

oh fuck wait nvm

104,0

that's "print in immediate mode: 0"
ie print the literal value 0
so why am i printing out 3?

oh, it's because i made a mistake in my print function

i had this:

    println!(">>> {}", memory[args[0] as usize]);

but it should have been this:

    println!(">>> {}", args[0]);

annnd that fixes it and makes my program no longer crash
lolll

ez!

ok i tidied up

still a few more done to resolve

===

7/15/20

finished up 5b!

TODO how can we associate operations' code more closely with their structs? will traits get involved here?

DONE try out a logging library
    https://fasterthanli.me/articles/getting-in-and-out-of-trouble-with-rust-futures has an example
    pretty_env_log it is

===

7/16/20

took a peek at 6a

idea so far:

* construct a tree from the input
* each node in the tree has a `depth` u32
* walk the tree, sum all the depths

constructing the tree will be interesting though

i think first we'll have to parse each line into a tuple of strings
into a hashmap actually imo!
yeah that's the way to go
and then build the tree based on that hashmap of directional relationships

maybe use a stack along the way while building the tree?

hrm hrm hrm
so a single body can have multiple satellites
but each body can only orbit one thing
so there's like a directionality there in the relationship

constructing a hashmap of {satellite: body} is straightforward enough
but how do you walk through that hashmap in order to construct a tree?

i think i want to make a hashmap of {body: vec_of_satellites}
it'll involve a lot of allocations but it'll work fine

ugh
ok so that's fine
but now making the tree is hard :)

do i even need a separate tree?
can i not just walk this hashmap?

i can walk it :)

===

7/18/20

ok, 6b

so we need to figure out how many "orbit transfers" between us and santa
my plan so far:

parse another map of orbits, keep both

so right now i have an outward-facing map of {body: satellites}
i also want an inward-facing map of {satellite: body}

let's come up with terms for these

lol how about BodyToSatellites and SatelliteToBody?
keep it simple

ok cool, done
so now what?

we use satellite_to_body["SAN"] to figure out where he is
and then so the idea i had the other day was

you have a function that's like

find_path_to(destination_body: &str, origin_body: &str, body_to_satellites: &BodyToSatellites) -> Option<u32>

which returns a number like 5 if it finds a path to origin starting from destination, or none if it doesn't

and so starting at san's current position, you call find_path_to("YOU")
and if it returns Some(u32) you have your answer
and if it doesn't, then you walk up the SatelliteToBody chain until you hit a body that has multiple satellites

maybe it'd be worth having `find_path_to()` also take a, like, "candidates" arg, because we'll know that
"YOU" _definitely isn't_ in the direction that we're _coming from_, and instead find_path_to() should only
be checking paths that involve the _other_ satellites of "origin"

anyway that's the rough idea

let's try to get some of this down into code and see how it looks

i'm gonna skip that "candidates" arg stuff for now
it's a perf optimization and kinda fiddly to get right
can reach for it later if we need it

it worked! didnt need candidates after all :)

ok, looking at 7a
to start, we need to come up with the permutations of [0, 1, 2, 3, 4]
gonna go with itertools .permutations()

ok cool that was pretty ez! just fun with iterators and .fold()

ok 7b is gonna be a lot more involved
looks fun!

===

7/19/20

ok let's get into 7b

i've been a bit nervous about it
i'm worried that these little computers are going to need to run in parallel and like have interconnected dependencies
on each other's inputs/outputs
but we'll see!!

"Eventually, the software on the amplifiers will halt after they have
processed the final loop. When this happens, the last output signal from
amplifier E is sent to the thrusters."

having trouble figuring out how to make sense of that

do i need to change the `computer` system so that each program halts temporarily whenever it produces output?
maybe i could have `run_program()` return an enum as part of its return value

right now it returns

(Memory, Output)

but maybe i could change it to return

enum ComputerState {
    Running,
    Halted
}

struct Computer {
    memory: Memory,
    output: Output,
    state: ComputerState
    // XXX ALSO INSTRUCTION POINTER
}

i think that would work.

let me reread the prompt a few more times to make sure i'm interpreting it correctly before i go through all this work

TODO also have `run_program` take some sort of, like, `halt_level` input
that defaults to `EXIT`
but that can also be set to `OUTPUT`

except rust doesn't have default values, o well

ok run_program() is going to need to take a Computer, and computer is going to have a few more fields
eg input and instruction_pointer

and i don't think i want ComputerState to be a part of Computer
instead i think i want `run_program()` to return a tuple of (Computer, halt_reason)

ok cool so
that was a lot of work in refactoring and fixing up preexisting callsites/tests
kind of a pain tbh
but i _think_ i did it right? we'll see

ok i think i have an infinite loop happening
yeah i definitely do
well dang!

how do i debug that??
do i have to read the 7.txt program and figure out why it's behaving this way?

it's kinda long!

ohhhh

ok i think i suspect what the problem is

so i stopped the program a bit early and looked at what the outputs were for each computer
and i noticed that they were repeating - computers 0, 1, 2, 3, 4  always gave the same outputs
and then i added a println() at the start of run_program() showing what the computer's instruction pointer was

and i see this

run_program starting with a computer at instruction_pointer 0
run_program starting with a computer at instruction_pointer 0
run_program starting with a computer at instruction_pointer 0
run_program starting with a computer at instruction_pointer 0
run_program starting with a computer at instruction_pointer 0
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16

so! i think the issue here is that i'm not incrementing the instruction pointer
before halting the program when i break early due to an output instruction being hit!!!!

let's try incrementing the instruction pointer and seeing if this infinite loop goes away
it did :)

ok cool so
i messed around with rayon a bit
and then i was like: hey, i wonder if this made a difference?
i had added rayon to days 3 and 7
and it looked initially like maybe there was some difference
but then i set up criterion
and it turned out that it made no difference!!!

so i was like, ok nvm let's look at a flamegraph
and according to the flamegraph, we actually spend the bulk of our time in day 4
specifically, four::write_password_to_buffer()
which, what gives?!

time to reread that function

ok it looks like this

fn write_password_to_buffer(number: i32, buffer: &mut Password) {
    for (i, digit) in number
        .to_string()
        .chars()
        .map(|x| x.to_digit(10).unwrap())
        .enumerate()
    {
        buffer[i] = digit;
    }
}

i'm sure that it's the `.to_string()` part that's the bad part
so, rather than generating numbers in a range, then converting them into strings, then parsing each char as a digit,
then writing that back into a buffer digit by digit

let's do something more direct!

ok so here's the measurements from benchmarking four by itself
[75.454 ms 76.239 ms 77.121 ms]

ok and i finally got my reimplementation working

four                    time:   [5.1523 ms 5.2919 ms 5.4431 ms]
                        change: [-93.248% -93.059% -92.848%] (p = 0.00 < 0.05)
                        Performance has improved.

:)))))))

ninety three percent improvement!!!

sick

so that was interesting
for a while there i was fighting the borrow checker
i originally had

struct PasswordRange<'a> {
    buffer: &'a mut Password,
    upper_bound: u32,
    current_number: u32,
}

and then i was trying to impl Iterator on it
and have .next() return a &Password

but that wasn't working and i couldn't figure it out
but then https://stackoverflow.com/questions/25702909/can-i-write-an-iterator-that-mutates-itself-and-then-yields-a-reference-into-its
was really helpful
basically the idea is that: if i'm returning references to this buffer,
but my calls to .next() are continuing to mutate the buffer,
then that's invalid behavior; .collect() is an interesting example to think about, for instance

so i changed it to

struct PasswordRange {
    upper_bound: u32,
    current_number: u32,
}

and wrote a separte, standalone function that takes a number and writes it to a buffer
so i pulled these two behaviors apart - starting at one number and counting up, vs writing a number to a buffer -
and i ended up with a system that works

incidentally

starting at one number and counting up is what ranges do already
i don't need to implement a separate standalone range struct from scratch
so let's delete that!!!!

okay awesome

all-solutions/all solutions
                        time:   [118.47 ms 122.96 ms 131.50 ms]
                        change: [-51.712% -45.625% -37.691%] (p = 0.00 < 0.05)
                        Performance has improved.

forty five percent of the all-solutions runtime has gone away!!!

super neat

let's play around with what's left

flamegraph shows me that the bulk of what's left is 3a, 3b, and 2b
so let's try rayon!
