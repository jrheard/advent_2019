7/11/20

let's do this!
starting with day 1

alg was pretty straightforward

when i got to part b, i initially tried to use a loop {}
but i was having issues reassigning a var that lived outside of the loop
couldn't figure out the answer by googling
so i switched to recursion which made the problem go away :]

next up, i had this utility function

pub fn parse_ints_from_file(filename: &str) -> Vec<i32> {
    let contents = fs::read_to_string(filename).unwrap();

    contents
        .lines()
        .map(|x| x.parse::<i32>().unwrap())
        .collect()
}

and i wanted to figure out how to make it generic

i ended up trying this out

pub fn parse_ints_from_file<T: FromStr + Debug>(filename: &str) -> Vec<T> {
    let contents = fs::read_to_string(filename).unwrap();
    contents.lines().map(|x| x.parse::<T>().unwrap()).collect()
}

but it gives this error:

error[E0599]: no method named `unwrap` found for enum `std::result::Result<T, <T as std::str::FromStr>::Err>` in the current scope
 --> src/util.rs:8:45
  |
8 |     contents.lines().map(|x| x.parse::<T>().unwrap()).collect()
  |                                             ^^^^^^ method not found in `std::result::Result<T, <T as std::str::FromStr>::Err>`
  |
  = note: the method `unwrap` exists but the following trait bounds were not satisfied:
          `<T as std::str::FromStr>::Err: std::fmt::Debug`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0599`.
error: could not compile `advent_2019`.

which i can't figure out what to make of.

made a rust playground link:
https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=ffeee4b54d862e99387b644c9d03d19b
and sent it to smt asking for advice!

will sent back this:

pub fn parse_ints_from_file_generic<T: FromStr + Debug>(filename: &str) -> Vec<T> where <T as std::str::FromStr>::Err: std::fmt::Debug {
    let contents = fs::read_to_string(filename).unwrap();

    contents
        .lines()
        .map(|x| {
            let parsed = x.parse::<T>();
            parsed.unwrap()
        })
        .collect()
}

which he acknowledges is hideous

smt solved it!!

pub fn parse_lines_from_file<T: FromStr>(filename: &str) -> Vec<T> {
    let contents = fs::read_to_string(filename).unwrap();

    contents
        .lines()
        .map(|x| {
            x.parse::<T>()
                .map_err(|_| format!("unable to parse {:?}", x))
                .unwrap()
        })
        .collect()
}

he says:
    unwrap() expects to print the "Debug" of whatever the Error was from the Result type
    so it requires that the error implements Debug
    that's why mapping the error to a string fixed it, because String implements Debug

neat!

happened to open this article about docs

https://blog.guillaume-gomez.fr/articles/2020-03-12+Guide+on+how+to+write+documentation+for+a+Rust+crate
    this is very good!
    no_run is interesting
    so is the thing about putting # at the beginning of lines that you don't want to show up in the docs

    rustdoc lints are neat too! v good for libraries obviously

ok, so looking at day 2

you have a tape
you have instructions, groups of four ints (or one int for stop-program)

opcode 1 is add
1, idx_1, idx_2, dst

opcode 2 is mul
2, idx_1, idx_2, mul

opcode 99 is stop program

you process an instruction - a group of 4 integers on the tape - and then step forward 4 to the next one

so! we need a tape

it'll be a vec of i32s

===

7/12/20

ok day 2 was pretty ez and also pretty fun

looks like it's the setup for some future days

i'll definitely be extracting this run_program() stuff out into a separate file for reuse later
but for now let's just go right into day 3

ok so 3 is interesting
one particularly interesting thing about it is that the grid has no specified size

so i could just try to make a huge 2d vector but that would be dumb and gross
but like it would work, just be inefficient and slow

is there a more efficient way to represent this?

what if each wire is represented as a series of (x, y) positions?

that seems better to me

then we could just check to see which elements are in both vectors

DONE learn more about into_iter, https://stackoverflow.com/questions/34733811/what-is-the-difference-between-iter-and-into-iter

https://hermanradtke.com/2015/06/22/effectively-using-iterators-in-rust.html
    "I tend to use .iter() most. I try to be very concious and deliberate
    about when I move resources and default to borrowing (or referencing)
    first. The reference created by .iter() is short-lived, so we can move or
    use our original value afterwards. If you find yourself running into does
    not live long enough, move errors or using the .clone() function, this is
    a sign that you probably want to use .into_iter() instead."

done profile 3a, i'm expecting to see huge slowdown bc of tons of tiny allocations
    https://carol-nichols.com/2017/04/20/rust-profiling-with-dtrace-on-osx/ good tips

i think that it's gonna be bc i make so many tiny strings
i think that instead it would be a lot better to read each wire string in one pass
eg have a function that returns a slice of the string up until the next comma, then operate on that

looks like most of our time is actually spent initializing the hashset?

https://stackoverflow.com/questions/44575380/is-there-any-way-to-insert-multiple-entries-into-a-hashmap-at-once-in-rust

ok you know what
this is actually all fine
when built in release mode, the whole program so far runs in 0.04 seconds
so 3a is fine for now
let's see if it falls over when it comes time for 3b though!!

it didn't :)

ok, i've been reading chapters of the book here and there
just finished structs and enums
and made it to the modules chapter!
but i think a lot changed after the paper book was written, re: modules, 2018 edition, etc
so i'm going to read the online version of that chapter instead, hopefully it's more up to date

https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html
    ya, in https://github.com/rust-lang/book/issues/1888 carol says ch 7 was "totally reworked"

    struct fields are private by default, but can be made public one by one
    by contrast, enums are also private by default, but if they're public then all of their variants are public
    which makes sense!

    oh, i figured out why i couldn't use `use` in this new project
    it was because i didn't have a `src/lib.rs` like i do in advent_2018

    "Using a semicolon after mod front_of_house rather than using a block
    tells Rust to load the contents of the module from another file with the
    same name as the module."

oooh https://doc.rust-lang.org/stable/edition-guide/ should be a good reread

ok cool

4a was easy to implement

kinda slow tho! nothing crazy, but not fast

for fun i flipped the conditionals around, checking nondecreasing first, and that made it about twice as fast
neat!

and then i changed it so that
instead of making a jillion tiny vectors from scratch
we just allocate a single vector that we use as a buffer
and that shaved the bulk of the rest of the time off :]
not my usual way of doing things, but there's a reason it's a common pattern!

ok let's look at day 5!

so it looks like it's time to revisit the opcodes/memory/program stuff

we're handling two more opcodes, with different lengths

so i think it's time to make opcodes a more first-class concept

or tbh maybe not, i think i can get away with a long match() for now

i'm not sure what the appropriate tool here would be - structs? enums?

i guess there could be an Opcode struct like this

struct Opcode {
    opcode: i32,
    num_args: usize,
}

but then so where does the code live that runs the operation for a particular opcode?

ugh yeah i'll just stick with a match for now
i'll figure out something better later

ok yeah so nvm i went with that struct idea

struct and a match

workin ok so far!

it was necessary+helpful bc the number of args is important to know so that we can
advance the instruction pointer appropriately

ok five is gonna be complicated :)

input+output
and modes
eek

===

7/13/20

ok let's take a look at 5a again

Parameter modes are stored in the same value as the instruction's opcode. The
opcode is a two-digit number based only on the ones and tens digit of the
value, that is, the opcode is the rightmost two digits of the first value in
an instruction. Parameter modes are single digits, one per parameter, read
right-to-left from the opcode: the first parameter's mode is in the hundreds
digit, the second parameter's mode is in the thousands digit, the third
parameter's mode is in the ten-thousands digit, and so on. Any missing modes
are 0.

maybe a parse_instruction() fn that returns (opcode: i32, mode: i32)

ahhh i see

took me a second to notice this:

Parameter modes are single digits, *****one per parameter******, read
right-to-left from the opcode: the first parameter's mode is in the hundreds
digit, the second parameter's mode is in the thousands digit, the third
parameter's mode is in the ten-thousands digit, and so on. Any missing modes
are 0.

ok wow this shit is interesting

definitely need a function just for this

but how to get it to not allocate a ton of tiny vecs when parsing/representing parameter modes?

i guess it could take as input a buffer vec<i32> that's initialized with zeroes

    Parameters that an instruction writes to will never be in immediate mode.

makes sense

    Integers can be negative: 1101,100,-1,4,0 is a valid program (find 100 + -1, store the result in position 4).

interesting!

ok so i hacked on 5a for a bit and i thought i had implemented it right
but the output commands are printing out 3
and they're supposed to be printing out 0
and also it crashes after a while
so clearly i've done something wrong

let's work this program out by hand

3,225

take an int (1) as input, store it to 225

1,225,6,6

add the value at 255 and the value at 6, and store the result to 6
the value at 255 is 1
the value at 6 is 1100
so the result is 1101, which we store to 6

1101,1,238,225

add 1 and 238 and store the result to 225
the result is 239, which we store to 225

104,0

print out the value at 0

which is 3!!!!!!
what gives????????

i must be interpreting this program incorrectly somehow

oh fuck wait nvm

104,0

that's "print in immediate mode: 0"
ie print the literal value 0
so why am i printing out 3?

oh, it's because i made a mistake in my print function

i had this:

    println!(">>> {}", memory[args[0] as usize]);

but it should have been this:

    println!(">>> {}", args[0]);

annnd that fixes it and makes my program no longer crash
lolll

ez!

ok i tidied up

still a few more done to resolve

===

7/15/20

finished up 5b!

TODO how can we associate operations' code more closely with their structs? will traits get involved here?

DONE try out a logging library
    https://fasterthanli.me/articles/getting-in-and-out-of-trouble-with-rust-futures has an example
    pretty_env_log it is

===

7/16/20

took a peek at 6a

idea so far:

* construct a tree from the input
* each node in the tree has a `depth` u32
* walk the tree, sum all the depths

constructing the tree will be interesting though

i think first we'll have to parse each line into a tuple of strings
into a hashmap actually imo!
yeah that's the way to go
and then build the tree based on that hashmap of directional relationships

maybe use a stack along the way while building the tree?

hrm hrm hrm
so a single body can have multiple satellites
but each body can only orbit one thing
so there's like a directionality there in the relationship

constructing a hashmap of {satellite: body} is straightforward enough
but how do you walk through that hashmap in order to construct a tree?

i think i want to make a hashmap of {body: vec_of_satellites}
it'll involve a lot of allocations but it'll work fine

ugh
ok so that's fine
but now making the tree is hard :)

do i even need a separate tree?
can i not just walk this hashmap?

i can walk it :)

===

7/18/20

ok, 6b

so we need to figure out how many "orbit transfers" between us and santa
my plan so far:

parse another map of orbits, keep both

so right now i have an outward-facing map of {body: satellites}
i also want an inward-facing map of {satellite: body}

let's come up with terms for these

lol how about BodyToSatellites and SatelliteToBody?
keep it simple

ok cool, done
so now what?

we use satellite_to_body["SAN"] to figure out where he is
and then so the idea i had the other day was

you have a function that's like

find_path_to(destination_body: &str, origin_body: &str, body_to_satellites: &BodyToSatellites) -> Option<u32>

which returns a number like 5 if it finds a path to origin starting from destination, or none if it doesn't

and so starting at san's current position, you call find_path_to("YOU")
and if it returns Some(u32) you have your answer
and if it doesn't, then you walk up the SatelliteToBody chain until you hit a body that has multiple satellites

maybe it'd be worth having `find_path_to()` also take a, like, "candidates" arg, because we'll know that
"YOU" _definitely isn't_ in the direction that we're _coming from_, and instead find_path_to() should only
be checking paths that involve the _other_ satellites of "origin"

anyway that's the rough idea

let's try to get some of this down into code and see how it looks

i'm gonna skip that "candidates" arg stuff for now
it's a perf optimization and kinda fiddly to get right
can reach for it later if we need it

it worked! didnt need candidates after all :)

ok, looking at 7a
to start, we need to come up with the permutations of [0, 1, 2, 3, 4]
gonna go with itertools .permutations()

ok cool that was pretty ez! just fun with iterators and .fold()

ok 7b is gonna be a lot more involved
looks fun!

===

7/19/20

ok let's get into 7b

i've been a bit nervous about it
i'm worried that these little computers are going to need to run in parallel and like have interconnected dependencies
on each other's inputs/outputs
but we'll see!!

"Eventually, the software on the amplifiers will halt after they have
processed the final loop. When this happens, the last output signal from
amplifier E is sent to the thrusters."

having trouble figuring out how to make sense of that

do i need to change the `computer` system so that each program halts temporarily whenever it produces output?
maybe i could have `run_program()` return an enum as part of its return value

right now it returns

(Memory, Output)

but maybe i could change it to return

enum ComputerState {
    Running,
    Halted
}

struct Computer {
    memory: Memory,
    output: Output,
    state: ComputerState
    // XXX ALSO INSTRUCTION POINTER
}

i think that would work.

let me reread the prompt a few more times to make sure i'm interpreting it correctly before i go through all this work

TODO also have `run_program` take some sort of, like, `halt_level` input
that defaults to `EXIT`
but that can also be set to `OUTPUT`

except rust doesn't have default values, o well

ok run_program() is going to need to take a Computer, and computer is going to have a few more fields
eg input and instruction_pointer

and i don't think i want ComputerState to be a part of Computer
instead i think i want `run_program()` to return a tuple of (Computer, halt_reason)

ok cool so
that was a lot of work in refactoring and fixing up preexisting callsites/tests
kind of a pain tbh
but i _think_ i did it right? we'll see

ok i think i have an infinite loop happening
yeah i definitely do
well dang!

how do i debug that??
do i have to read the 7.txt program and figure out why it's behaving this way?

it's kinda long!

ohhhh

ok i think i suspect what the problem is

so i stopped the program a bit early and looked at what the outputs were for each computer
and i noticed that they were repeating - computers 0, 1, 2, 3, 4  always gave the same outputs
and then i added a println() at the start of run_program() showing what the computer's instruction pointer was

and i see this

run_program starting with a computer at instruction_pointer 0
run_program starting with a computer at instruction_pointer 0
run_program starting with a computer at instruction_pointer 0
run_program starting with a computer at instruction_pointer 0
run_program starting with a computer at instruction_pointer 0
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16
run_program starting with a computer at instruction_pointer 16

so! i think the issue here is that i'm not incrementing the instruction pointer
before halting the program when i break early due to an output instruction being hit!!!!

let's try incrementing the instruction pointer and seeing if this infinite loop goes away
it did :)

ok cool so
i messed around with rayon a bit
and then i was like: hey, i wonder if this made a difference?
i had added rayon to days 3 and 7
and it looked initially like maybe there was some difference
but then i set up criterion
and it turned out that it made no difference!!!

so i was like, ok nvm let's look at a flamegraph
and according to the flamegraph, we actually spend the bulk of our time in day 4
specifically, four::write_password_to_buffer()
which, what gives?!

time to reread that function

ok it looks like this

fn write_password_to_buffer(number: i32, buffer: &mut Password) {
    for (i, digit) in number
        .to_string()
        .chars()
        .map(|x| x.to_digit(10).unwrap())
        .enumerate()
    {
        buffer[i] = digit;
    }
}

i'm sure that it's the `.to_string()` part that's the bad part
so, rather than generating numbers in a range, then converting them into strings, then parsing each char as a digit,
then writing that back into a buffer digit by digit

let's do something more direct!

ok so here's the measurements from benchmarking four by itself
[75.454 ms 76.239 ms 77.121 ms]

ok and i finally got my reimplementation working

four                    time:   [5.1523 ms 5.2919 ms 5.4431 ms]
                        change: [-93.248% -93.059% -92.848%] (p = 0.00 < 0.05)
                        Performance has improved.

:)))))))

ninety three percent improvement!!!

sick

so that was interesting
for a while there i was fighting the borrow checker
i originally had

struct PasswordRange<'a> {
    buffer: &'a mut Password,
    upper_bound: u32,
    current_number: u32,
}

and then i was trying to impl Iterator on it
and have .next() return a &Password

but that wasn't working and i couldn't figure it out
but then https://stackoverflow.com/questions/25702909/can-i-write-an-iterator-that-mutates-itself-and-then-yields-a-reference-into-its
was really helpful
basically the idea is that: if i'm returning references to this buffer,
but my calls to .next() are continuing to mutate the buffer,
then that's invalid behavior; .collect() is an interesting example to think about, for instance

so i changed it to

struct PasswordRange {
    upper_bound: u32,
    current_number: u32,
}

and wrote a separte, standalone function that takes a number and writes it to a buffer
so i pulled these two behaviors apart - starting at one number and counting up, vs writing a number to a buffer -
and i ended up with a system that works

incidentally

starting at one number and counting up is what ranges do already
i don't need to implement a separate standalone range struct from scratch
so let's delete that!!!!

okay awesome

all-solutions/all solutions
                        time:   [118.47 ms 122.96 ms 131.50 ms]
                        change: [-51.712% -45.625% -37.691%] (p = 0.00 < 0.05)
                        Performance has improved.

forty five percent of the all-solutions runtime has gone away!!!

super neat

let's play around with what's left

flamegraph shows me that the bulk of what's left is 3a, 3b, and 2b
so let's try rayon!

here's what 3 looks like on the rayon branch
individual              time:   [18.340 ms 18.598 ms 18.885 ms]

and here's master

three                   time:   [14.308 ms 14.395 ms 14.500 ms]

so, rayon didn't help for 3
because i'm a dummy and didn't look at the flame graph closely enough
the stuff i .par_iter()'d wasn't the stuff that was slow
it's wire_intersections() that's slow

so, i'm gonna back out my rayon change from 3

individual              time:   [14.029 ms 14.111 ms 14.215 ms]
                        change: [-25.383% -24.125% -22.950%] (p = 0.00 < 0.05)
                        Performance has improved.

yup!
ok cool

so, how do we speed up wire_intersections?
i'm actually not sure that we can!
i forgot the details of this problem
wire_1 and wire_2 are really long vectors with tons of (x, y) pairs
let's see how long they are

[src/three.rs:44] wire_1.len() = 153537
[src/three.rs:44] wire_2.len() = 149380

yeah, that's a lot of items!
so i think my current implementation is fine
i'm not sure how to solve this problem without representing these wires as super long vectors of (x, y) pairs

ok, so three can't easily be sped up
well then, what else is on the docket?
let's take a look at two

ok, here's two right now
time:   [25.520 ms 26.106 ms 26.768 ms]

let's see if there's a reasonable spot for rayon to fit in
there is :) :) :)

here's the result!

individual              time:   [696.42 us 718.97 us 745.37 us]
                        change: [-97.316% -97.210% -97.074%] (p = 0.00 < 0.05)
                        Performance has improved.

97%!!!!!!!!!!

ok cool sweet
let's merge

ok rad
now let's look at six
maybe make it a bit less recursive
here's six's measurements rn

individual              time:   [14.123 ms 14.231 ms 14.356 ms]

ok, i unrolled the recursion of the outer function, let's see what that did

individual              time:   [16.066 ms 16.829 ms 17.677 ms]
                        change: [+12.401% +18.257% +23.997%] (p = 0.00 < 0.05)
                        Performance has regressed.

hm, not helpful!
let's try unrolling the inner recursion

oh right, this is the problem where i was thinking about marking certain paths as not worth visiting
i think i could probably keep the recursion and just do that marking
bc the recursion is actually a good fit for the algorithm

so, let's do that

it helped a lot! :)

individual              time:   [1.6026 ms 1.6383 ms 1.6801 ms]
                        change: [-90.219% -89.601% -88.953%] (p = 0.00 < 0.05)
                        Performance has improved.

so where are we at on all_solutions rn?

all-solutions/all solutions
                        time:   [84.659 ms 89.329 ms 98.045 ms]
                        change: [-41.600% -29.692% -14.464%] (p = 0.00 < 0.05)
                        Performance has improved.

sick
it looks like i lost some lines in my dev diary from earlier
but i'm 99% positive that earlier i spent some time benchmarking all_solutions and got times
that were hovering right around 240ms

so this is a big improvement!

let's take a look at seven
time:   [8.3632 ms 8.4799 ms 8.6138 ms]

and now let's see it with rayon

individual              time:   [4.7613 ms 5.0371 ms 5.4016 ms]
                        change: [-43.492% -40.600% -35.971%] (p = 0.00 < 0.05)
                        Performance has improved.

3ms isn't much in the grand scheme of things, but 40% is nice!!!!!

===

7/20/20

ok cool

so i was poking around to see if people had suggestions for how to improve 3
and there aren't really any
except - instead of building two hashsets and intersecting them
you can just build one and do lookups on it while walking the other vector
interesting!
let's bench

before:
individual              time:   [15.972 ms 16.531 ms 17.253 ms]

after:
individual              time:   [9.4935 ms 9.8182 ms 10.174 ms]
                        change: [-43.695% -40.607% -37.473%] (p = 0.00 < 0.05)
                        Performance has improved.

all right, not bad!!!

cool, i think that's about as optimized as days 1-7 are gonna get for now
fun times!

DONE lol i don't think i realized that rust has while loops

===

7/22/20

ok cool so 8a was ez

there's a clippy lint firing, telling me i'm counting bytes "the naive way"
here's the timing from doing it the naive way

individual              time:   [46.515 us 46.840 us 47.268 us]

that is obviously plenty, plenty fast
let's try the bytecount crate now

and here's the bytecount version

individual              time:   [39.544 us 39.837 us 40.206 us]

very little difference
i'll still keep the bytecount code for funsies tho

ok nine looks interesting!
relative base is hopefully straightforward
DONE implement the write_arguments() portion of it

TODO:
    The computer's available memory should be much larger than the initial
    program. Memory beyond the initial program starts with the value 0 and can be
    read or written like any other memory.

DONE: (It is invalid to try to access memory at a negative address, though.)

DONE
    The computer should have support for large numbers. Some instructions
    near the beginning of the BOOST program will verify this capability.


let's figure this program out

109,1,204,-1,1001,100,1,100,1008,100,16,101,1006,101,0,99

109, 1
increment relative base by 1

204, -1
output 109

ok cool i ended up figuring out the issue - i hadn't fully implemented relative-base behavior in write_arguments()

TODO - still having an issue with the 9a program in test mode
TODO i think that the issue is my messed-up if-statement at the end of write_arguments
TODO augh revisit that

===

7/23/20

TODO figure out a way to refactor the big match expression in Computer.run()