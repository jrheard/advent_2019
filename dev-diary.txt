7/11/20

let's do this!
starting with day 1

alg was pretty straightforward

when i got to part b, i initially tried to use a loop {}
but i was having issues reassigning a var that lived outside of the loop
couldn't figure out the answer by googling
so i switched to recursion which made the problem go away :]

next up, i had this utility function

pub fn parse_ints_from_file(filename: &str) -> Vec<i32> {
    let contents = fs::read_to_string(filename).unwrap();

    contents
        .lines()
        .map(|x| x.parse::<i32>().unwrap())
        .collect()
}

and i wanted to figure out how to make it generic

i ended up trying this out

pub fn parse_ints_from_file<T: FromStr + Debug>(filename: &str) -> Vec<T> {
    let contents = fs::read_to_string(filename).unwrap();
    contents.lines().map(|x| x.parse::<T>().unwrap()).collect()
}

but it gives this error:

error[E0599]: no method named `unwrap` found for enum `std::result::Result<T, <T as std::str::FromStr>::Err>` in the current scope
 --> src/util.rs:8:45
  |
8 |     contents.lines().map(|x| x.parse::<T>().unwrap()).collect()
  |                                             ^^^^^^ method not found in `std::result::Result<T, <T as std::str::FromStr>::Err>`
  |
  = note: the method `unwrap` exists but the following trait bounds were not satisfied:
          `<T as std::str::FromStr>::Err: std::fmt::Debug`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0599`.
error: could not compile `advent_2019`.

which i can't figure out what to make of.

made a rust playground link:
https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=ffeee4b54d862e99387b644c9d03d19b
and sent it to smt asking for advice!

will sent back this:

pub fn parse_ints_from_file_generic<T: FromStr + Debug>(filename: &str) -> Vec<T> where <T as std::str::FromStr>::Err: std::fmt::Debug {
    let contents = fs::read_to_string(filename).unwrap();

    contents
        .lines()
        .map(|x| {
            let parsed = x.parse::<T>();
            parsed.unwrap()
        })
        .collect()
}

which he acknowledges is hideous

smt solved it!!

pub fn parse_lines_from_file<T: FromStr>(filename: &str) -> Vec<T> {
    let contents = fs::read_to_string(filename).unwrap();

    contents
        .lines()
        .map(|x| {
            x.parse::<T>()
                .map_err(|_| format!("unable to parse {:?}", x))
                .unwrap()
        })
        .collect()
}

he says:
    unwrap() expects to print the "Debug" of whatever the Error was from the Result type
    so it requires that the error implements Debug
    that's why mapping the error to a string fixed it, because String implements Debug

neat!

happened to open this article about docs

https://blog.guillaume-gomez.fr/articles/2020-03-12+Guide+on+how+to+write+documentation+for+a+Rust+crate
    this is very good!
    no_run is interesting
    so is the thing about putting # at the beginning of lines that you don't want to show up in the docs

    rustdoc lints are neat too! v good for libraries obviously

ok, so looking at day 2

you have a tape
you have instructions, groups of four ints (or one int for stop-program)

opcode 1 is add
1, idx_1, idx_2, dst

opcode 2 is mul
2, idx_1, idx_2, mul

opcode 99 is stop program

you process an instruction - a group of 4 integers on the tape - and then step forward 4 to the next one

so! we need a tape

it'll be a vec of i32s

===

7/12/20

ok day 2 was pretty ez and also pretty fun

looks like it's the setup for some future days

i'll definitely be extracting this run_program() stuff out into a separate file for reuse later
but for now let's just go right into day 3

ok so 3 is interesting
one particularly interesting thing about it is that the grid has no specified size

so i could just try to make a huge 2d vector but that would be dumb and gross
but like it would work, just be inefficient and slow

is there a more efficient way to represent this?

what if each wire is represented as a series of (x, y) positions?

that seems better to me

then we could just check to see which elements are in both vectors

TODO learn more about into_iter, https://stackoverflow.com/questions/34733811/what-is-the-difference-between-iter-and-into-iter

TODO profile 3a, i'm expecting to see huge slowdown bc of tons of tiny allocations