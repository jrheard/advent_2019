7/11/20

let's do this!
starting with day 1

alg was pretty straightforward

when i got to part b, i initially tried to use a loop {}
but i was having issues reassigning a var that lived outside of the loop
couldn't figure out the answer by googling
so i switched to recursion which made the problem go away :]

next up, i had this utility function

pub fn parse_ints_from_file(filename: &str) -> Vec<i32> {
    let contents = fs::read_to_string(filename).unwrap();

    contents
        .lines()
        .map(|x| x.parse::<i32>().unwrap())
        .collect()
}

and i wanted to figure out how to make it generic

i ended up trying this out

pub fn parse_ints_from_file<T: FromStr + Debug>(filename: &str) -> Vec<T> {
    let contents = fs::read_to_string(filename).unwrap();
    contents.lines().map(|x| x.parse::<T>().unwrap()).collect()
}

but it gives this error:

error[E0599]: no method named `unwrap` found for enum `std::result::Result<T, <T as std::str::FromStr>::Err>` in the current scope
 --> src/util.rs:8:45
  |
8 |     contents.lines().map(|x| x.parse::<T>().unwrap()).collect()
  |                                             ^^^^^^ method not found in `std::result::Result<T, <T as std::str::FromStr>::Err>`
  |
  = note: the method `unwrap` exists but the following trait bounds were not satisfied:
          `<T as std::str::FromStr>::Err: std::fmt::Debug`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0599`.
error: could not compile `advent_2019`.

which i can't figure out what to make of.

made a rust playground link:
https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=ffeee4b54d862e99387b644c9d03d19b
and sent it to smt asking for advice!

will sent back this:

pub fn parse_ints_from_file_generic<T: FromStr + Debug>(filename: &str) -> Vec<T> where <T as std::str::FromStr>::Err: std::fmt::Debug {
    let contents = fs::read_to_string(filename).unwrap();

    contents
        .lines()
        .map(|x| {
            let parsed = x.parse::<T>();
            parsed.unwrap()
        })
        .collect()
}

which he acknowledges is hideous

smt solved it!!

pub fn parse_lines_from_file<T: FromStr>(filename: &str) -> Vec<T> {
    let contents = fs::read_to_string(filename).unwrap();

    contents
        .lines()
        .map(|x| {
            x.parse::<T>()
                .map_err(|_| format!("unable to parse {:?}", x))
                .unwrap()
        })
        .collect()
}

he says:
    unwrap() expects to print the "Debug" of whatever the Error was from the Result type
    so it requires that the error implements Debug
    that's why mapping the error to a string fixed it, because String implements Debug

neat!

happened to open this article about docs

https://blog.guillaume-gomez.fr/articles/2020-03-12+Guide+on+how+to+write+documentation+for+a+Rust+crate
    this is very good!
    no_run is interesting
    so is the thing about putting # at the beginning of lines that you don't want to show up in the docs

    rustdoc lints are neat too! v good for libraries obviously

ok, so looking at day 2

you have a tape
you have instructions, groups of four ints (or one int for stop-program)

opcode 1 is add
1, idx_1, idx_2, dst

opcode 2 is mul
2, idx_1, idx_2, mul

opcode 99 is stop program

you process an instruction - a group of 4 integers on the tape - and then step forward 4 to the next one

so! we need a tape

it'll be a vec of i32s

===

7/12/20

ok day 2 was pretty ez and also pretty fun

looks like it's the setup for some future days

i'll definitely be extracting this run_program() stuff out into a separate file for reuse later
but for now let's just go right into day 3

ok so 3 is interesting
one particularly interesting thing about it is that the grid has no specified size

so i could just try to make a huge 2d vector but that would be dumb and gross
but like it would work, just be inefficient and slow

is there a more efficient way to represent this?

what if each wire is represented as a series of (x, y) positions?

that seems better to me

then we could just check to see which elements are in both vectors

DONE learn more about into_iter, https://stackoverflow.com/questions/34733811/what-is-the-difference-between-iter-and-into-iter

https://hermanradtke.com/2015/06/22/effectively-using-iterators-in-rust.html
    "I tend to use .iter() most. I try to be very concious and deliberate
    about when I move resources and default to borrowing (or referencing)
    first. The reference created by .iter() is short-lived, so we can move or
    use our original value afterwards. If you find yourself running into does
    not live long enough, move errors or using the .clone() function, this is
    a sign that you probably want to use .into_iter() instead."

TODO profile 3a, i'm expecting to see huge slowdown bc of tons of tiny allocations
    https://carol-nichols.com/2017/04/20/rust-profiling-with-dtrace-on-osx/ good tips

i think that it's gonna be bc i make so many tiny strings
i think that instead it would be a lot better to read each wire string in one pass
eg have a function that returns a slice of the string up until the next comma, then operate on that

looks like most of our time is actually spent initializing the hashset?

https://stackoverflow.com/questions/44575380/is-there-any-way-to-insert-multiple-entries-into-a-hashmap-at-once-in-rust

ok you know what
this is actually all fine
when built in release mode, the whole program so far runs in 0.04 seconds
so 3a is fine for now
let's see if it falls over when it comes time for 3b though!!

it didn't :)

ok, i've been reading chapters of the book here and there
just finished structs and enums
and made it to the modules chapter!
but i think a lot changed after the paper book was written, re: modules, 2018 edition, etc
so i'm going to read the online version of that chapter instead, hopefully it's more up to date

https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html
    ya, in https://github.com/rust-lang/book/issues/1888 carol says ch 7 was "totally reworked"

    struct fields are private by default, but can be made public one by one
    by contrast, enums are also private by default, but if they're public then all of their variants are public
    which makes sense!

    oh, i figured out why i couldn't use `use` in this new project
    it was because i didn't have a `src/lib.rs` like i do in advent_2018

    "Using a semicolon after mod front_of_house rather than using a block
    tells Rust to load the contents of the module from another file with the
    same name as the module."

oooh https://doc.rust-lang.org/stable/edition-guide/ should be a good reread

ok cool

4a was easy to implement

kinda slow tho! nothing crazy, but not fast

for fun i flipped the conditionals around, checking nondecreasing first, and that made it about twice as fast
neat!

and then i changed it so that
instead of making a jillion tiny vectors from scratch
we just allocate a single vector that we use as a buffer
and that shaved the bulk of the rest of the time off :]
not my usual way of doing things, but there's a reason it's a common pattern!

ok let's look at day 5!

so it looks like it's time to revisit the opcodes/memory/program stuff

we're handling two more opcodes, with different lengths

so i think it's time to make opcodes a more first-class concept

or tbh maybe not, i think i can get away with a long match() for now

i'm not sure what the appropriate tool here would be - structs? enums?

i guess there could be an Opcode struct like this

struct Opcode {
    opcode: i32,
    num_args: usize,
}

but then so where does the code live that runs the operation for a particular opcode?

ugh yeah i'll just stick with a match for now
i'll figure out something better later